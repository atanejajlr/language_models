<html>
<head>
  <title>The Evolution of Language Models: my notes</title>
  <style>
    body {
      margin: 0 auto;
      width: 744px;
      font-family: Source Serif Pro, serif;
      line-height: 32px;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.7);
      font-size: 21px;
    }
    h1, h2, h3 {
      font-family: Source Sans Pro, Helvetica, Arial, sans-serif;
    }
    h1 a, h1 a:visited {
      color: inherit;
      text-decoration: none;
    }
    h1 {
      line-height: 48px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 42px;
      margin: 32px 0 20px;
    }
    h2 {
      line-height: 32px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 26px;
      margin: 28px 0;
    }
    h3 {
      line-height: 28px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 21px;
      margin: 24px 0;
    }
    p {
      margin: 32px 0;
    }
    .created, .published {
      color: rgba(0, 0, 0, 0.55);
      font-size: 15px;
      line-height: 15px;
      margin: 20px 0;
    }
    .created + .published {
      margin-top: -12px;
    }
    blockquote {
      font-family: Georgia, Source Serif Pro, serif;
      font-style: italic;
      font-size: 24px;
      line-height: 36px;
      margin: 48px 120px;
      text-align: center;
    }
    a {
      word-wrap: break-word;
      outline: none;
      text-decoration: none;
      background-color: transparent;
      border: 0;
      color: #008CC9;
    }
    a:hover {
      text-decoration: underline;
    }
    a:visited {
      color: #8C68CB;
    }
    .center {
      text-align: center;
    }
    iframe {
      display: block;
      margin: 44px auto;
    }
    *:not(pre) + pre, pre:first-of-type {
      margin-top: 32px;
      padding-top: 32px;
    }
    pre:only-of-type {
      margin: 32px 0;
      padding: 32px;
    }
    pre {
      background: #F3F6F8;
      overflow-x: auto;
      display: block;
      font-size: 13px;
      font-family: monospace;
      line-height: 13px;
      padding: 0 32px 32px;
      white-space: pre;
    }
    a.embedded {
      background: #F3F6F8;
      display: block;
      padding: 32px;
      margin: 32px 0;
    }
    img {
      height: auto;
      max-width: 100%;
    }
    .slate-image-embed__resize-full-width img {
      width: 100%;
    }
    .series-logo {
      width: 48px;
      height: 48px;
      box-sizing: border-box;
      background-clip: content-box;
      border: 4px solid transparent;
      border-radius: 6px;
      object-fit: scale-down;
      float: left;
    }
    .series-title {
      font-size: 16px;
      font-weight: 600;
      vertical-align: top;
    }
    .series-description {
      color: rgba(0,0,0,.6);
      font-weight: 400;
      font-size: 14px;
      line-height: 20px;
    }
    div {
      margin: 32px 0;
    }
  </style>
</head>
<body>
    <img src="https://media.licdn.com/mediaD5612AQEuHDks37ANeA" alt="" title="" />
      <h1><a href="https://www.linkedin.com/pulse/evolution-language-models-my-notes-ajay-taneja">The Evolution of Language Models: my notes</a></h1>
    <p class="created">Created on 2023-06-08 16:58</p>
  <p class="published">Published on 2023-06-09 19:02</p>
  <div><h2>1.&nbsp;Introduction </h2><p>&nbsp;It has been a while that I had announced here on LinkedIn , about my next series of blogs starting from:</p><ul><li>Foundational Principles of Deep Learning</li><li>Evolution of Language Models</li></ul><p>And then each subsequent blog going into every unit / component of the Transformer Architecture including:</p><ul><li>Input Embedding</li><li>Positional Embeddings</li><li>Self-Attention and Multi-Headed Attention</li><li>Layer Normalization</li><li>Skip connections and other units that make up the Transformer architecture</li></ul><p>The first blog in the above series on the Foundational principles of Deep Learning can be found <a href="https://www.linkedin.com/pulse/foundational-principles-deep-learning-my-notes-ajay-taneja/?trackingId=sE7lKiTZRH%2BBRt9hleNUkg%3D%3D" target="_blank">here</a> .</p><p><br></p><p>This article is about the evolution of language models – the topic itself is a good fit for a detailed textbook – however, the content here is a consolidation of my notes from various sources – including Natural Language Processing specialization on Coursera [<a href="https://www.deeplearning.ai/courses/natural-language-processing-specialization/" target="_blank">https://www.deeplearning.ai/courses/natural-language-processing-specialization/</a>],&nbsp;Deep Learning Specialization by Andrew Ng [<a href="https://www.deeplearning.ai/courses/deep-learning-specialization/" target="_blank">https://www.deeplearning.ai/courses/deep-learning-specialization/</a>], several You-Tube Videos, open-source university lectures, open-source material of blog posts of other learners, research papers and my own interpretation of this fascinating subject.</p><p><br></p><p>Through this article, I have attempted to bring about the hierarchical evolution of language models talking about the following: n-gram models and their limitations and then moving into the Deep Learning era with Recurrent Neural Networks, Long Short-Term Memory Units (LSTMs) and the problems in these networks and then progressing into  Transformers with a detailed emphasis on the Attention Mechanism, talking at a higher level the architecture of the Transformer Architecture. </p><p><br></p><p>At the time I started writing/consolidating my notes on this topic – which was 2-3 weeks ago – I had not envisaged that this article would become as lengthy as it has but for me – I think it’s worth the effort. I’d re-iterate that these notes are for my own future reference as I apply these concepts in my work and personal (fun) projects but I’m happier if the content is useful to other learners in my LinkedIn community.</p><p><br></p><h2>2.&nbsp;Introduction to Language Modelling</h2><p>&nbsp;What is Language Modelling?</p><p>Most simplistically, Language Modelling is a task of predicting what word comes next – given a sequence of words. For example, given a piece of text:</p><p><em>The students opened their ---------------</em></p><p>&nbsp;</p><p>The possible answers could be,</p><ul><li>Books</li><li>Laptops</li><li>Exams</li><li>Minds</li></ul><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFEf12QV3LM-A" src="https://media.licdn.com/dms/image/D4D12AQFEf12QV3LM-A/article-inline_image-shrink_400_744/0/1686244102008?e=1691625600&amp;v=beta&amp;t=wLcXF2QcdYQYcAdhzDisIMN0hNjV_sKAlS18qUXCt94"><figcaption>Possible words that may make up the next word in the sentence</figcaption></figure><p>Thus, a formal definition of a language model is:</p><p><br></p><p>Given a sequence of words x(1), x(2), …., x(t), a language model will compute the probability distribution of the next word x(t+1):</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE2ulMYukHtdg" src="https://media.licdn.com/dms/image/D4D12AQE2ulMYukHtdg/article-inline_image-shrink_400_744/0/1686244162616?e=1691625600&amp;v=beta&amp;t=YhuT_OfN360-HYU6Joa7VBQsiZRj6yPMUBNBQ49WpXI"><figcaption>Conditional probability definition</figcaption></figure><p>The above probability distribution is a conditional probability.</p><p>The word x(t+1) can be any word in the vocabulary:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFH7qmrAbTV2A" src="https://media.licdn.com/dms/image/D4D12AQFH7qmrAbTV2A/article-inline_image-shrink_400_744/0/1686244207996?e=1691625600&amp;v=beta&amp;t=rM-TaHkdiTjQhYtx7njcGoN_kWu-rgGsr8t9h2j4TiU"><figcaption>Vocabular of all possible words that make up a language model</figcaption></figure><p>The word x(t+1) will come from a vocabulary – that is, there is a pre-defined list of words that we are considering.</p><p><br></p><p><strong>Thus, language models can be viewed as a classification task because there is a pre-defined number of possibilities.&nbsp;</strong></p><p><br></p><p><strong>Other ways of thinking about Language Modelling</strong></p><p>One can think of a Language Model as a system that assigns probability to a piece of text. For example, if we have some text x(1), …., x(T) then the probability of this text – according to the Language Model is:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQF8v_8I2i0SdQ" src="https://media.licdn.com/dms/image/D4D12AQF8v_8I2i0SdQ/article-inline_image-shrink_400_744/0/1686244719769?e=1691625600&amp;v=beta&amp;t=E8PsrAsby977-brOoMlWbd8cYg9upDi9ux97wBGB1cI"><figcaption>Language model as a probability of a piece of text</figcaption></figure><p><br></p><h2>3.&nbsp;Daily use of Language Models </h2><p>&nbsp;</p><p>Some examples of Language models may be outlined as follows:</p><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Auto-completion – next word prediction on smart phones</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE482NYYmD6mw" src="https://media.licdn.com/dms/image/D4D12AQE482NYYmD6mw/article-inline_image-shrink_400_744/0/1686244805620?e=1691625600&amp;v=beta&amp;t=1Iio_mw-EkiroFvzyBZKf57lZxnYSGpsH9YYjWmnpeE"><figcaption>Language model on a smart phone</figcaption></figure><p>2.    Word suggestions by Google:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHj-H1Ze7hbLA" src="https://media.licdn.com/dms/image/D4D12AQHj-H1Ze7hbLA/article-inline_image-shrink_1000_1488/0/1686244863910?e=1691625600&amp;v=beta&amp;t=3H4Ru-Msnm7RycCtINgOIOFp7f3e-hOp4l735zludD8"><figcaption>Language model in Google<br><br><br><br></figcaption></figure><h2>3.&nbsp;&nbsp;&nbsp;How to learn a Language Model?</h2><p>&nbsp;</p><p>In the pre-Deep Learning era – the answer to How to learn a Language Model would be “n-gram” model. Thus, let us discuss about n-grams.</p><p><strong>Definition of n-gram</strong></p><p>By definition an n-gram is a series of “n” consecutive words. </p><p>Thus, </p><p>A unigram is just all of the individual words.</p><ul><li>unigram: “the”, “students”, “opened”, “their”.</li></ul><p>&nbsp;</p><p>A bigram will be a consecutive series of pair of words.</p><ul><li>bigram: “the students”, “students opened”, “opened their”.</li></ul><p>&nbsp;</p><p>And so on for trigrams and 4 grams as shown below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHyinF6YN7O7A" src="https://media.licdn.com/dms/image/D4D12AQHyinF6YN7O7A/article-inline_image-shrink_400_744/0/1686245061287?e=1691625600&amp;v=beta&amp;t=-Q_Rg4S8C2ciHYjd7JlQmf0CouC_40sajGsoBpS2Buc"><figcaption>n-grams</figcaption></figure><p>Thus, the core idea of an n-gram is that in order to predict what word comes next, we would collect a bunch of statistics of how frequent different n-grams are from some kind of training data and then use those words to predict the next word.</p><p><br></p><p>Let us add some detail:</p><p><br></p><p>To make an n-gram language model, </p><ul><li>First, make a simplifying assumption: x(t+1) depends only on the preceding (n-1) words. So, the conditional probability of x(t+1) given all the words so far depends only on the last (n-1) words</li></ul><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGadE-uo3nYhw" src="https://media.licdn.com/dms/image/D4D12AQGadE-uo3nYhw/article-inline_image-shrink_400_744/0/1686245219077?e=1691625600&amp;v=beta&amp;t=v8HSFVRMfRh2r_e5WEdq7wHbdQsslOxDpEHlkdaYGvw"><figcaption>Conditional probability definition</figcaption></figure><p><br></p><p>&nbsp;So, by the definition of conditional probability, we can say this probability is the ratio of 2 different probabilities.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFxtAH0kN__Tg" src="https://media.licdn.com/dms/image/D4D12AQFxtAH0kN__Tg/article-inline_image-shrink_400_744/0/1686245343348?e=1691625600&amp;v=beta&amp;t=_SuT5TvaSsu0n5PrkfW25Uf5XmeRvgw20r-7vakIFFs"><figcaption>Conditional probability as a ratio</figcaption></figure><p>The question then remains:</p><p>How do we get the n gram and (n-1) probabilities – these are obtained by counting them in some large corpus of text – that is your training data.</p><p>That is, mathematically,</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE_JKJeIoNbmw" src="https://media.licdn.com/dms/image/D4D12AQE_JKJeIoNbmw/article-inline_image-shrink_400_744/0/1686245383684?e=1691625600&amp;v=beta&amp;t=2KX6SlHFEodUXWiH0J4WP-FqhVueOJSwOVSxuPZPuKM"><figcaption>Conditional probability - as a ratio of counts in the corpus (statistical approximation)</figcaption></figure><p><br></p><h2>4.&nbsp;&nbsp;&nbsp;Example to learn a 4-gram Language Model</h2><p>&nbsp;</p><p>Let us say we are going to learn a 4-gram language model and we have a piece of text that says:</p><p><strong>As the proctor started the clock, the students opened their ---------</strong></p><p>&nbsp;</p><p>We want to predict the word in the blank above.</p><p>&nbsp;</p><p>Since we are using a 4-gram language model, our assumption is that the word in the blank depends only n the last 3 words. So, we lose all of the context except the last 3 words as shown below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHrlUfFP-EB8g" src="https://media.licdn.com/dms/image/D4D12AQHrlUfFP-EB8g/article-inline_image-shrink_400_744/0/1686245613117?e=1691625600&amp;v=beta&amp;t=679g9_dym2cJynedJOy2bRELr9LscITVDKEaeEvBpqU"><figcaption>Losing the context because of a 4-gram language model</figcaption></figure><p>So, the probability of a word “w” given given (n-1) = 3 words is:</p><p>Number of times – i.e., count of the words <em>“student opened their w”</em> divided by the count of n-1 words in the corpus n-1 words above being <em>“students opened their”.</em></p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE4VGMOVqdr9A" src="https://media.licdn.com/dms/image/D4D12AQE4VGMOVqdr9A/article-inline_image-shrink_400_744/0/1686245664364?e=1691625600&amp;v=beta&amp;t=KJDqO-oNkSyvncJQ6FTT4IQWIEdDj5rkstGecJjOuYY"><figcaption>Conditional probability definition for the 4-gram example</figcaption></figure><p>Thus, for example, that in the corpus/training data, we see:</p><ul><li>“students opened their” occurred 1000 times</li><li>“students opened their books” occurred 400 times</li></ul><p>Then,</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGdNjW6yvdgCw" src="https://media.licdn.com/dms/image/D4D12AQGdNjW6yvdgCw/article-inline_image-shrink_400_744/0/1686245728917?e=1691625600&amp;v=beta&amp;t=LOutoqLx-1L9SQPrA6ZPz2-gSQfJKTpclr64K4BHqes"><figcaption>Solution of the 4-gram model</figcaption></figure><p><br></p><p>And suppose, </p><p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“students opened their exams” occurred 100 times, then,</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFSJ0-a1Y-_5A" src="https://media.licdn.com/dms/image/D4D12AQFSJ0-a1Y-_5A/article-inline_image-shrink_400_744/0/1686245831003?e=1691625600&amp;v=beta&amp;t=mEJoH-gyxuGM6XrDbdVf8SIvsuBAz-pYl7r2hHr06MI"><figcaption>Conditional probability of the next word being 'exams'</figcaption></figure><p><br></p><p><br></p><p>This is a classic example underscoring that it was “not” a good idea to discard the proctor context here i.e., the word “proctor” which was not a part of 4-gram model.</p><p><br></p><p>Considering the complete sentence:</p><p><br></p><p><strong>As the proctor started the clock, the students opened their ---------</strong></p><p>&nbsp;</p><p><strong>It is clear considering the complete sentence that “exams” was more likely to be the last word than books – although “books” had a higher probability than “exams” considering a 4-gram model. Thus, it is clear we were throwing away too much of context – that is one problem with a n-gram language model.</strong></p><p>&nbsp;</p><p>There are some other problems too:</p><p><br></p><p><strong>Sparsity problems</strong></p><p><br></p><p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;what happens if the numerator is 0 – sometimes an uncommon word like “petridishes” might also be the word “w” – although petridishes is an uncommon word and might not occur in the training data – it might be possible the student is a Biology student and hence the last word might be “petridishes” – so if a word does not occur in the training data, n-gram will assign zero probability to that event</p><p>&nbsp;</p><p>One solution to the problem might be to add some probability to every word in the vocabulary so that every word has a small probability of occurring. This is called “Smoothing” because every word has a small probability of occurrence.</p><p>&nbsp;</p><p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Back—off to a trigram language model: Next problem is what if the denominator is 0 – that is what if we did not see the trigram <em>“students opened their”</em> in the training data? If this happened, we will not be able to calculate the probability distribution at all! If this happens, we would then <strong>back-off </strong>taking the probability of last 2 words than the last 3 words.</p><p>&nbsp;</p><p>These kinds of problems become worse as you increase “n”</p><p>&nbsp;</p><p>Below is a diagram describing the problems a bit succinctly:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFOQWgnN_Ra3g" src="https://media.licdn.com/dms/image/D4D12AQFOQWgnN_Ra3g/article-inline_image-shrink_1000_1488/0/1686245924740?e=1691625600&amp;v=beta&amp;t=-eqSpnd6_-4J-M3V1R3lfB3D0YjMNKnm0Da_g8V94RI"><figcaption>Problems in n-gram language model</figcaption></figure><p><br></p><p><strong>Storage problems</strong></p><p>Considering the example:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQEtlHB1PcJrzw" src="https://media.licdn.com/dms/image/D4D12AQEtlHB1PcJrzw/article-inline_image-shrink_400_744/0/1686246033865?e=1691625600&amp;v=beta&amp;t=9ShdNmGDHtKMjoY4BXgzJcwWyND6HtOTK3rfnZd3Wes"></figure><p><br></p><p>Here we need to think about what we will have to store in order to use the n-gram language model - for the numerator we will have to store all the counts of “students opened their” – as “n” increases the number / count increases and hence more storage – size of n gram model gets bigger</p><p><br></p><p><strong>How incoherent the text generated from the Trigram model could be!</strong></p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGxkZwTZ7KJ-Q" src="https://media.licdn.com/dms/image/D4D12AQGxkZwTZ7KJ-Q/article-inline_image-shrink_400_744/0/1686246126410?e=1691625600&amp;v=beta&amp;t=edTiqhBmobqaV8BbI-QAcKOHG3RsMCMJsZ6aSwooTBI"><figcaption>Gramatically correct but highly incoherent text from a Trigram model</figcaption></figure><p><br></p><h2>5.&nbsp;Neural Networks for language modelling: Recurrent Neural Networks</h2><p>&nbsp;</p><p>Recurrent Neural Networks as discussed below are much more efficient than the n-gram models discussed because of the notion of memory as elaborated in detail in the subsequent paragraphs. They incorporate the concept involving ‘time-stepping’ and thus capture the semantic meaning of the sentence. </p><p><br></p><p>In the paragraphs below, I have attempted to evolve through he concept of recurrent neural networks starting from the concept of perceptron to a single layered neural network and then stacking such units and connecting them together incorporating the modelling of memory through the information being passed from the one unit &nbsp;to the next unit </p><p>&nbsp;</p><p><strong>5.1&nbsp;&nbsp;Understanding Recurrent Neural Networks</strong></p><p><br></p><p>Firstly, let us start from the very fundamentals by revisiting the concept of the perceptron and develop a solid understanding of the changes that should be done to the neural network architecture in order to handle sequential data. Starting from the concept of perceptron,&nbsp;we defined the set of inputs from&nbsp;x1 through xn&nbsp;and each of these numbers multiplied by a weight matrix&nbsp;and then they're going to all be added together&nbsp;to form this internal state of the perceptron which we'll say is z and then this value z is&nbsp;passed through a non-linear activation function&nbsp;to produce a predictive output y_hat as shown in the figure below;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQF-3AohGN1QRg" src="https://media.licdn.com/dms/image/D4D12AQF-3AohGN1QRg/article-inline_image-shrink_400_744/0/1686248214774?e=1691625600&amp;v=beta&amp;t=kPhhnFmISOBl0dkONeUfPuFZ2puDSPXCKKcEk7jJTUc"><figcaption>Figure: Perceptron Revisited</figcaption></figure><p><br></p><p>It may be recalled that with the perceptron, one can have multiple inputs coming in and since we know we’re talking of sequence modelling, these inputs can be considered as being from a single&nbsp;time step in a sequence. We could extend from the single perceptron to now a layer of perceptron’s to yield multi-dimensional outputs as shown in the figure below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQG3rLYyeVpEfw" src="https://media.licdn.com/dms/image/D4D12AQG3rLYyeVpEfw/article-inline_image-shrink_400_744/0/1686248268070?e=1691625600&amp;v=beta&amp;t=Xp0rbRoQqPGsFf1UDF5Y8QPal4ScD3_HbRtc0uZZfZA"><figcaption>Figure: Feed forward neural network</figcaption></figure><p><br></p><p>It should be underscored that the above mechanism does not have a notion of time or a sequence. All the inputs and the outputs above can be thought of that coming from a fixed time step of a sequence.</p><p><br></p><p>Now – lets us simplify things. Let us simplify the diagram and collapse the hidden layer as shown:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQG5OXlFZKto9w" src="https://media.licdn.com/dms/image/D4D12AQG5OXlFZKto9w/article-inline_image-shrink_400_744/0/1686248300972?e=1691625600&amp;v=beta&amp;t=gSvF42bPkv0URsQjYcgr9lf7sPnwcuImvcH8Haxgg78"><figcaption>Figure: A Recurrent Neural Network Unit</figcaption></figure><p><br></p><p>Here, the input and the output vector are depicted of being of length m and length n respectively. Now, if we apply the same model repeatedly for each time step in the sequence, we get a sense of how we could handle the individual inputs across different time steps as shown in the figure below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFRbuSVOT3Gsg" src="https://media.licdn.com/dms/image/D4D12AQFRbuSVOT3Gsg/article-inline_image-shrink_400_744/0/1686248454955?e=1691625600&amp;v=beta&amp;t=CpSHNLf0fBSoMRUc8r6LIhxQ8j3KrVS7OMuAlxXYxgE"><figcaption>Figure: Handling Individual Time Steps</figcaption></figure><p>All the models depicted above are replicas of each other at different time steps. The output vector y_hat_t is going to be the function of the input at that time step as shown below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQG90nc7KGGXCg" src="https://media.licdn.com/dms/image/D4D12AQG90nc7KGGXCg/article-inline_image-shrink_400_744/0/1686248477750?e=1691625600&amp;v=beta&amp;t=jP0ud7vEIJVNVygfYVUEm4X-BUa7gP3hnkDtzOHhD-s"><figcaption>Prediction from an RNN unit</figcaption></figure><p>Now taking a step back we know if we’re considering sequence data it is very likely that considering the sequence data the output of a label at a&nbsp;particular time step is going to depend on inputs at the prior time steps – so, we cannot treat the individual time steps as isolated steps.&nbsp;Thus, we have to consider the relationship which is inherent to the sequence data considering the inputs between different time steps. So how to address this?</p><p>&nbsp;</p><p>We need to link the information in the computation of the network at different time steps to each other. Specifically, we are going to introduce internal memory or cell state denoted h_t;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHoC9SCo8eaEA" src="https://media.licdn.com/dms/image/D4D12AQHoC9SCo8eaEA/article-inline_image-shrink_400_744/0/1686248513997?e=1691625600&amp;v=beta&amp;t=Ezvj-vE9-Z5VVf4_K5ee-9USFkAM_GEja3smBlAjSPw"><figcaption>Figure: Neurons with Recurrence</figcaption></figure><p>The h_t is going to be the memory that will be maintained by the neurons and the network itself and this state can be passed from time step to time step across time. The key idea here is that by having the recurrence relation we’re capturing the notion of memory. So, what this means now is that the network output predictions and the computations are not only the function of the input at a time step but also the memory of the cell state denoted by h_t. Thus, the output depends both on the current input as well as the past computations and the past learning that occurs. One can define this relationship by means of functions that map the input to the outputs as below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQG1mMTjXRGeJQ" src="https://media.licdn.com/dms/image/D4D12AQG1mMTjXRGeJQ/article-inline_image-shrink_400_744/0/1686250719585?e=1691625600&amp;v=beta&amp;t=VBNWZ1M3JGoiGgt_SfAGE1LEdrOhgzeVVtURoQNcweM"></figure><p>As we can see that we can describe the neurons via a recurrence relation which means the cell state depends upon the current input and again on prior cell states. It is exactly this idea (see figure&nbsp;below) of recurrence relation that provides the intuition of the key operation behind the recurrent neural networks or RNNs and through the sections 3 and 4 below we build upon the understanding of the mathematics of the recurrence relation and the operations that define the RNN behaviour.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGNs2WBnNrTmQ" src="https://media.licdn.com/dms/image/D4D12AQGNs2WBnNrTmQ/article-inline_image-shrink_400_744/0/1686250751060?e=1691625600&amp;v=beta&amp;t=UHjZgLbatnXWqbSV4wHAFZ00loTGxrHLwqu3wPW1bV4"><figcaption>Figure: The Recurrence Relation in RNNs</figcaption></figure><p><br></p><p><strong>5.2&nbsp;&nbsp;Recurrent Neural Networks: Mathematics </strong></p><p>Now, let us formalize the discussion a bit. The key idea is that the RNNs as described above maintain an internal state defined by h_t which is updated at each time step as the sequence is processed and this is done by the recurrence relation which specifically defines how the state is updated at the time step. Specifically, we define the internal cell state h_t;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQH383-SB4F6QQ" src="https://media.licdn.com/dms/image/D4D12AQH383-SB4F6QQ/article-inline_image-shrink_400_744/0/1686250844906?e=1691625600&amp;v=beta&amp;t=2J8V2hPzIOh3qnVhGso4gtsx0Llgr9iX3socYPbbOwc"><figcaption>The internal cell state in a recurrent unit</figcaption></figure><p>This internal cell state is defined by a function that can be parametrized by a set of weights “w”. These weights w will be learnt during training such a network. The function f_w is going to take as input both: the input at the current time step x_t as well as the prior cell state h_t-1;</p><p><strong>&nbsp;</strong></p><p>The key feature of the RNNs is that they use the same function and the same parameters whilst processing the sequence and of course the weights change during the course of the training but during each iteration of the training the same set of weights are going to be applied across each of individual time steps.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQF5E8deFncXPw" src="https://media.licdn.com/dms/image/D4D12AQF5E8deFncXPw/article-inline_image-shrink_400_744/0/1686250924213?e=1691625600&amp;v=beta&amp;t=YAuwZ8QYhFgnk2AQEfOCumJaLJ12ut8gnyLlfXu5fHg"></figure><p><br></p><p><strong>5.3&nbsp;&nbsp;RNN Computation: State Update and Output</strong></p><p>RNN computations include both the internal cell state update h_t as well as the output prediction itself. Let us now walk-through how these RNN computations are defined:</p><p>Firstly, we are going to consider the input vector x_t and then we are going to update the hidden state, the updated hidden state is;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQH4NRt8StOxMg" src="https://media.licdn.com/dms/image/D5612AQH4NRt8StOxMg/article-inline_image-shrink_400_744/0/1686250977465?e=1691625600&amp;v=beta&amp;t=1u03gCQ2EGGZZDiKGtxwfAwlDq5HTna1gf8J24r5cv4"></figure><p>As seen in the above equation; the function used in the calculation of the hidden state is a standard neural network function as seen in the beginning of the section 2. Again, as evident from the above equation, this internal cell state h_t is going to depend upon both: the input x_t and previous cell state h_t-1 and we are going to multiply each of the terms by their respective weight matrices and we are going to add the result and apply a non-linear activation function to the sum of the 2 terms. The non-linear activation function here is going to be the hyperbolic tangent.</p><p>Then to generate the output at a given time step we take the internal hidden state at a given time step ‘’t’ and multiply by a separate weight matrix which inherently produces a modified version of the hidden state which actually forms the output prediction;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQHZl2FjlR3oOg" src="https://media.licdn.com/dms/image/D5612AQHZl2FjlR3oOg/article-inline_image-shrink_400_744/0/1686251039604?e=1691625600&amp;v=beta&amp;t=j6fpWwdA6Yb4M4VVNzoz-LrQ6PxpD2XM318VJNdHQMY"></figure><p><br></p><p>This gives the mathematics of how an RNN updates its hidden state and produces the predicted output. The RNNs described above can be represented as below;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQElM9_SrMtBIQ" src="https://media.licdn.com/dms/image/D5612AQElM9_SrMtBIQ/article-inline_image-shrink_400_744/0/1686251093390?e=1691625600&amp;v=beta&amp;t=8momfXW2Bpo1kmj9UCugM4Ap0ddmBNeuBbtSe1XdkEY"><figcaption>A Recurrent Neural Network</figcaption></figure><p><br></p><p>It should be emphasized that in a RNN we will be re-using the same weight matrices at every time step.</p><p><br></p><p><strong>5.4 &nbsp;&nbsp;Training the RNNs</strong></p><p>For RNNs, the forward pass through the network consists of going forward across time and updating the cell state based on the input as well as the previous state and then generating the output. The loss is computed at each time step and then finally the individual losses are summed to get the total loss.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQFvj6K7Qhz6Zw" src="https://media.licdn.com/dms/image/D5612AQFvj6K7Qhz6Zw/article-inline_image-shrink_400_744/0/1686251182859?e=1691625600&amp;v=beta&amp;t=9tP0POn41uox3Lls9CZ_pLiJBkTnRhaiPGMP5xf-zN8"><figcaption>Figure: RNNs – back-propagation through time</figcaption></figure><p><br></p><p><strong>The Vanishing and Exploding Gradients problem in RNNs:</strong></p><p>RNNs suffered a serious problem relating to vanishing and exploding gradients and thus were superseded by LSTMs and then Transformers! Let's understand what's the Vanishing and Exploding gradients problem</p><p> </p><p> Let's say you're utilising RNNs for machine translation task. Each unit of RNN can be thought of as separate neural network unit and the connected to the successive unit. RNNs possess an input state, output stare and internal memory state which retains the information of preceding units.</p><p> </p><p> We proceed forward as we'd proceed in a feed forward network and predict output of in each unit of RNN and carry the information (memory) forward.</p><p> </p><p> Next for training the RNN we'd calculate the loss of each unit, and the total loss will be the sum of losses of all units. We then do Back-propagation which created problems. This is because if we're dealing with a long sequence, the back propagation will involve computing several gradients to update the weights and by the time we reach the first unit there would have several gradients computed especially for a long sequence problem</p><p> </p><p> Now if the gradients is &lt;1 the multiplication of several small numbers will create what is termed as "vanishing" gradient and if the gradient is &gt;1 the multiplication only several numbers results in what's termed as exploding gradient</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQHEDy5nl3LIlg" src="https://media.licdn.com/dms/image/D5612AQHEDy5nl3LIlg/article-inline_image-shrink_400_744/0/1686251241691?e=1691625600&amp;v=beta&amp;t=KaCG16itwdFJx2hu8BxNiEZRJNjnHsYHRncdOAkeRTY"><figcaption>The Vanishing and the Exploding Gradient Problem</figcaption></figure><p>The problem of exploding gradients may be mitigated by “gradient clipping” that tries to constrain the large gradients so that the multiplication does not blow them up. The vanishing gradient problem may be mitigated through: activation function, weight initialisation and network architecture.&nbsp;</p><p><br></p><h2>6.&nbsp;&nbsp;Neural Networks for language modelling: Long Short-Term Memory Units (LSTMs)</h2><p>LSTMs may be termed as the best solutions of vanishing gradient problems of RNNs discussed above. Let’s have a high-level view of the architecture of LSTMs.</p><p>LSTMs may be termed as a special variety of RNNs that were designed to handle longer sequences of data – fundamentally, LSTMs learn “what to remember” and “what to forget”. </p><p>The basic anatomy of the LSTMs may be defined as being comprised of:</p><p>&nbsp;</p><p>LSTMs may be termed as the best solutions of vanishing gradient problems of RNNs discussed above. Let’s have a high-level view of the architecture of LSTMs.</p><p>LSTMs may be termed as a special variety of RNNs that were designed to handle longer sequences of data – fundamentally, LSTMs learn “what to remember” and “what to forget”. </p><p>The basic anatomy of the LSTMs may be defined as being comprised of:</p><p>a)&nbsp;Cell state – which can be thought of as its memory.</p><p>&nbsp;</p><p>b) Hidden state – where computations are performed during the training to decide on what changes to make.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQH3w0rgAKfkIw" src="https://media.licdn.com/dms/image/D4D12AQH3w0rgAKfkIw/article-inline_image-shrink_400_744/0/1686294636461?e=1691625600&amp;v=beta&amp;t=wEfFxobrY_VVbqxOxB3kd9KqmLy_NxLbHZaqVqimaUk"><figcaption>Figure: LSTMs – cell state and hidden state</figcaption></figure><p>The hidden state has 3 gates to pass through before the entire operation is performed again. Each gate plays a role in deciding how much information to pass along and how much to leave behind. The series of gates physically allow the gradients to go unchanged so that the risk of vanishing and exploding gradients is mitigated.</p><p>&nbsp;</p><p><strong>6.1&nbsp;&nbsp;Architecture of LSTMs</strong></p><p>Let us now understand the architecture of LSTMs in an intuitive sense without involving any mathematics:</p><p>LSTMs incorporated a cell state and hidden state. The cell state got updated during each loop of the training process. The update to the cell state occurred through 3 gates (part of the hidden state) as described below.</p><p> </p><p> The cell state could be thought of retaining the memory relating to the necessary context for long sequences .</p><p> </p><p> The update to the cell state occurred through 3 gates which are termed as:</p><p> </p><p> a) The "Forget" Gate</p><p> b) The "Input" Gate</p><p> c) The "Output" Gate</p><p> </p><p> The "forget" gate looks at the information from the previous cell state and decides what information is required and what is not for the cell state to be updated. As it might be envisaged, this is&nbsp;comprised of a Sigmoid layer, 0 to forget and 1 to remember!</p><p> </p><p> The input gate decides what values are to be updated compared to the previous cell state. This is done through the sigmoid layer and then these values are passed through a tanh layer to get a vector of new values</p><p> The output state combines the above to create an update state.</p><p> The loop above is repeated during the each iteration of the training process and during each step the weights are updated.</p><p> </p><p>Mathematically the update of the weights through each step of the training process helped keeping the gradients constant and closer to 1 avoiding the vanishing and exploding gradient problem of RNNs.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFb2WRlKS4rfA" src="https://media.licdn.com/dms/image/D4D12AQFb2WRlKS4rfA/article-inline_image-shrink_400_744/0/1686294725133?e=1691625600&amp;v=beta&amp;t=BQMOEO_tgRdfMYpUNxpoD55GpC8MrtmSL0eqHGgIZA8"><figcaption>Figure: Basic Anatomy of LSTMs</figcaption></figure><p><br></p><p><strong>6.2&nbsp;&nbsp;Key Ideas in Long-Short-Term-Memory Units</strong></p><p>The key idea behind LSTMs is that they can selectively add or remove information to and from the internal cell states using structures called “Gates”. The Gates contain standard neural network layer like the “sigmoid” and pointwise multiplication.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHWr_cwGKO-XA" src="https://media.licdn.com/dms/image/D4D12AQHWr_cwGKO-XA/article-inline_image-shrink_1000_1488/0/1686294932531?e=1691625600&amp;v=beta&amp;t=I2qIGNat_HLp-xJaSog_bie176_bxDCxDx8ubyVqBVY"><figcaption>Figure: In LSTMs information is added or removed through <br>structures called gates.</figcaption></figure><p>Now, let us see what these gates are doing. For example, we have a sigmoidal activation function&nbsp;- this is going to force anything that passes through the gate to be between 0 and 1. One can think of think of this as modulating and capturing how much of the input should be passed through between nothing [0] and everything [1] which effectively “gates” the flow of information.&nbsp;LSTMs use this type of operation by first forgetting the irrelevant history secondly by storing the relevant information and thirdly by updating the internal cell state and finally (fourth) updating the output.&nbsp;</p><p><br></p><p><strong>6.3&nbsp;&nbsp;How LSTMs process information?</strong></p><p>The steps describing how LSTMs process information are described below:</p><p>1.&nbsp;The first step is to forget the irrelevant parts of the previous state, and this is achieved by taking the previous state and passing it through one of the sigmoid gates which can be thought of as a step modulating the flow by how much information should be passed or kept out.</p><p>&nbsp;</p><p>2.&nbsp;&nbsp;&nbsp;The next step is to find out what part of the new information and what part of the old information is relevant, and this stored into the cell state.</p><p>The highlight of the LSTMs is that they maintain a separate value of the cell state ct in addition to what was introduced previously ht. The ct is going to be selectively updated by the gated operations.</p><p><br></p><p>3. Finally, we can return an output from the LSTM – this is an interacting layer – the output gate that can control what information that’s encoded in the cell state is ultimately outputted and&nbsp;sent to the network as input in the following time step. This operation controls the value of the output yt as well as the cell state that’s passed from time step to time step in the form of ht.</p><p>The above steps are highlighted through figures below.</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFUvUCemivJMQ" src="https://media.licdn.com/dms/image/D4D12AQFUvUCemivJMQ/article-inline_image-shrink_400_744/0/1686295164770?e=1691625600&amp;v=beta&amp;t=yyHCKn4ZZY5deU5nb1wmUCLsy894r4qLnCcaN2ltRyk"><figcaption>Figure: LSTM Process – Step 1 – ‘Forget’: LSTMs forget irrelevant <br>parts of previous state</figcaption></figure><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHbD04WlT5T9w" src="https://media.licdn.com/dms/image/D4D12AQHbD04WlT5T9w/article-inline_image-shrink_400_744/0/1686295185387?e=1691625600&amp;v=beta&amp;t=d9fcL6p1Osp6VCil2NSFK__1o4N0uCbh2sIOeNRNb-w"><figcaption>Figure: LSTM Process – Step 2 – ‘Store’: LSTMS store relevant <br>new information into the cell state</figcaption></figure><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGnYWWEsxyOuQ" src="https://media.licdn.com/dms/image/D4D12AQGnYWWEsxyOuQ/article-inline_image-shrink_400_744/0/1686295272698?e=1691625600&amp;v=beta&amp;t=ji9d7pHH1gH2GMpnXExfx9WOGO0wivRYl84DVa0GW5g"><figcaption>Figure: LSTM Process – Step 3 – ‘Update’:  LSTMs selectively <br>update cell state values</figcaption></figure><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGnAKfNz21UYQ" src="https://media.licdn.com/dms/image/D4D12AQGnAKfNz21UYQ/article-inline_image-shrink_400_744/0/1686295290398?e=1691625600&amp;v=beta&amp;t=hOMjLZgWkz_xOx5uIHJvaK_aT-wxT2HIl91u4ec_rxA"><figcaption>Figure: LSTM Process – Step 4 – ‘Output’: Output gate controls <br>information passed to the next time step.</figcaption></figure><p><strong>6.4&nbsp;Key take away points from LSTMs:</strong></p><ul><li>The key-take away from LSTMs is that they can regulate information flow in storage thus they can effectively better capture long term dependencies and overcome the vanishing gradient problem. LSTMs maintain a separate cell state from what is outputted that is ct</li></ul><p>&nbsp;</p><ul><li>The use of the gates to control the flow of information by: forgetting the irrelevant information from the past history, storing the relevant information from the current input, updating the cell state and outputting the information at each time step.</li></ul><p>&nbsp;</p><ul><li>It is the maintenance of the separate cell state which allows the back propagation through time with uninterrupted gradient flow and more effective training. Thus, LSTMs are commonly used in deep learning practise – until recently – where they have been largely replaced by Attention models which are discussed next!</li></ul><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHew77xmh-VgA" src="https://media.licdn.com/dms/image/D4D12AQHew77xmh-VgA/article-inline_image-shrink_1000_1488/0/1686295415212?e=1691625600&amp;v=beta&amp;t=CS0d3rk-bTJzZbDXmOMPKuj--J-WnAOP_V9WjU7lFMw"></figure><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFDJ8_IwqqpFw" src="https://media.licdn.com/dms/image/D4D12AQFDJ8_IwqqpFw/article-inline_image-shrink_400_744/0/1686295426663?e=1691625600&amp;v=beta&amp;t=8Sa6Ldy4bKr-DUYnzakR8K3GMxghc-Dl_WpquCpWcYQ"><figcaption>Figure: LSTMs - Uninterrupted gradient flow</figcaption></figure><p><br></p><h2>7.&nbsp;&nbsp;Problems in RNNs and LSTMs</h2><p>&nbsp;</p><p>Recurrent Neural Networks – as discussed above – were the state of the art of sequence-to-sequence modelling. </p><p>1.&nbsp;&nbsp;RNNs are slow to train - the input data needs to be passed sequentially or serially one after the other. We need inputs of the previous state to make any operations on the current state. Such sequential flow does not make use of the GPUs which are essentially designed for parallel computation. </p><p>&nbsp;</p><p>2.  Further, RNNs cannot deal with long sequences very well which leads to the problem of vanishing and exploding gradients as explained above. LSTMs solve the problem of long sequences to an&nbsp;<em>extent,</em>&nbsp;but they are slower than RNNs!</p><p><br></p><h2>8.&nbsp;Transform Neural Network Architecture</h2><p>&nbsp;</p><p>Now, from the above discussion it was clear that we needed to bring all time steps together – to eliminate sequential processing – as well as to extract information related to the context / semantic meaning of the sentence from the input data. The key idea being – to be able to – identify and “attend” to what is important in a sequential stream of data. And this was the notion of “attention” or “self-attention” which is a powerful concept and was first introduced in the paper titled: Attention is All You Need published by Google during 2017.&nbsp;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHfh7f4FCIfdA" src="https://media.licdn.com/dms/image/D4D12AQHfh7f4FCIfdA/article-inline_image-shrink_1000_1488/0/1686295553004?e=1691625600&amp;v=beta&amp;t=1mtR_fYSYSEEE8qsQCX5by4NS3DbTre-0btMCgtO2h0"><figcaption>Figure: 2017 Google Release - Attention Is All You Need</figcaption></figure><p>Attention – the key operation – in the Transformer architecture is a very intuitive idea. So, it may be worthwhile developing some intuition of the concept of Attention.&nbsp;</p><h2>8.1 Intuition Behind Attention</h2><p><strong>Extracting the most important features of an image</strong></p><p>In this article, I will be focussing on the idea of self-attention - i.e., attending to most important parts of the input example. Consider an image as shown in the figure below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQGpkV2yfPfI3A" src="https://media.licdn.com/dms/image/D4D12AQGpkV2yfPfI3A/article-inline_image-shrink_400_744/0/1686296506371?e=1691625600&amp;v=beta&amp;t=acJThGOEVaYZuabun7FywflDJXAagZqPEEv5LC4bok8"><figcaption>Figure: Image to illustrate the concept of Attention</figcaption></figure><p>This is the image of the superman and out goal is to extract information of the important features of this image. Looking at the image, we might be scanning this image in our mind’s pixel by pixel in our eyes and our brain might be doing some kind of processing wherein we can look at the important parts of the image – in the above we might focus on the attire and thus understand that it’s the image of the superman. Thus, what’s perhaps happening is that our brains are identifying which parts of the image are to be “attended” to and then extract he features which deserve the highest “Attention”.</p><p>&nbsp;</p><p><strong>You-Tube Video Search</strong></p><p>The problem is similar to “search”. For example, one might be searching for searching for some videos related to “language models evolution” – this is our “query”. </p><p>We might get some possible outputs. These outputs contain some information related to the “title” – these outputs are termed as “keys”. Now, we want to compute a metric of similarity or relevance between the “query” and the “keys” and retain the videos of high similarity metric – the video of the metric of high similarity are the videos that we need to pay “attention” to and will subsequently watch those videos. The relevant videos of high similarity metric are called the “value”&nbsp;</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFsAmASmZ-JvQ" src="https://media.licdn.com/dms/image/D4D12AQFsAmASmZ-JvQ/article-inline_image-shrink_1000_1488/0/1686296565697?e=1691625600&amp;v=beta&amp;t=ZhwtohHnXV9kKmQvBKU4gsZmuC--uIG0AYqZ-vjj7Vs"><figcaption>Figure: YouTube video search example to capture the essence of the meaning of Query, Key, Value used in the concept of Attention</figcaption></figure><h3>8.2 Demystifying the Attention Mechanism&nbsp;</h3><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHYQerhh8eBiw" src="https://media.licdn.com/dms/image/D4D12AQHYQerhh8eBiw/article-inline_image-shrink_1000_1488/0/1686298454114?e=1691625600&amp;v=beta&amp;t=7_siTI3ebfviqb2YgKR4yjziVu7pH-GD6KzjN14rzTo"><figcaption>Figure: The Transformer Architecture and the Attention Mechanism</figcaption></figure><p><strong>Processing the text through the Transformers:</strong></p><p>Let us go back to the language example given a sentence of the form “Hi How are you” our goal is to “identify” and “attend” to features in the input which are relevant to the semantic meaning of the sentence. </p><p>Thus, we have a sequence, we have a order of words, we have to eliminate recurrence – that is, we pass all the words – i.e. word embeddings – into the network simultaneously. We still need to find a way to encode and capture the order and positional dependence. This is done through the positional encoding which captures the inherent order information present in the sequence. This is explained below. </p><p><strong>How is text encoded through the Transformer architecture?</strong></p><p>Transformers do not model the order of the input anywhere; it is important to encode the order of the input. This happened in positional encoding.&nbsp;</p><p>Transformer has to know what comes after the other word – before or after – and not do any permutations. This is where positional embeddings come in. They are kind of a “hint” for the transformer about the whereabouts of the word within the sequence. </p><p>We add the positional embedding to the input embedding – making it move a certain distance from where it currently is as shown in the figure below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQF9fuD1VkyEUQ" src="https://media.licdn.com/dms/image/D4D12AQF9fuD1VkyEUQ/article-inline_image-shrink_1000_1488/0/1686298514888?e=1691625600&amp;v=beta&amp;t=I3yVuNHKY5Jh9NLxOIxQYcSLbHQMnzCRhVQsOZE-nK8"><figcaption>Figure: Explanation for the concept of positional encoding</figcaption></figure><p><br></p><p>Positional embedding are the identifiers that are added to the original word embedding for the Transformers to know the order of the sequence. </p><p>The positional embedding should fulfil certain requirements:</p><p>Every position must have the same identifier irrespective of the sequence length. It should be noted that the positional embeddings push the original input embedding, care should be taken to see that the input embedding do not get drifted away too far away so that the semantic meaning of the embedding is lost.</p><p>We could think of numbering the positional embedding as 1, 2, 3 but that violates the above rule.We thus need to keep the value of the positional embedding bounded.</p><p>To keep the values of the input embedding bounded, we choose functions of sine and cosine, sines and cosines are bounded between -1 and +1 range from – infinity to + infinity. We take both sines and cosines because: had we taken only sines we might have got some repeated position values which is not permitted by. Hence, we take both sines and cosines as shown below:</p><p><br></p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQFUPAHo9CZH5w" src="https://media.licdn.com/dms/image/D4D12AQFUPAHo9CZH5w/article-inline_image-shrink_400_744/0/1686298565292?e=1691625600&amp;v=beta&amp;t=E4-2VUcmBdTmyrzFd3IAfBSqi6f0dULl4_ua6RoaFQ8"><figcaption>Positional encoding: Mathematical modelling</figcaption></figure><p>Above</p><p>pos = denotes the position/order of the word in the sentence</p><p>i = index in the embedding vector</p><p>d_model = embedding length</p><p><br></p><p><strong>Arriving at the Query, Key, Value Matrices </strong></p><p>Next, our goal is taking the encoding and figure out what to attend to exactly like the intuitive idea of You-Tube video search explained in the section above – that is – extracting the query, extracting the key and extracting the value and relate them to each other. We use the neural network layers to do exactly this. </p><p>Given the positional encoding, we apply a neural network layer transforming the positional encoding – first generating a query vector – then we use another neural network layer – which will have a separate set of weights to generate key vector and then another network layer with another separate set of weights to generate a value vector. </p><p><strong>&nbsp;</strong></p><p><strong>Computing the Attention Weighting</strong></p><p>Now, given the Query, Key and Value matrices we compare them to each other to find out where in the self-input the network should attend to figure out what is important. We compute a Attention Score which is the similarity metric between the Query and the Key Matrices</p><p>IT should be underscored that the Query and Key similarity may be computed mathematically by taking the dot product as shown in the figure below. This is also known as “cosine similarity”. </p><p>This is the Attention Weighting showing what the network should attend to. This operation gives us a score defining how components of the input data are related to each other. As it may be noticed from the figure below, the words which are more closely related to each other will have a high attention score. These scores are passed through a softmax layer to transform the scores into numbers between 0 and 1. </p><p>&nbsp;</p><p><strong>Extracting features of High Attention</strong></p><p>Finally, since we have this matrix – the attention score – that captures the notion of similarity, we can use the attention score to extract features that deserve high attention – and that is the final step in the self-attention mechanism.</p><p>We take the attention matrix and multiply it by the value vector to give us a transformed set of vectors form the initial input embedding vector to a series of vectors that deserve high attention.</p><p>The series of steps discussed above are illustrated below:</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQHfopHj3b7Wjg" src="https://media.licdn.com/dms/image/D5612AQHfopHj3b7Wjg/article-inline_image-shrink_400_744/0/1686325407122?e=1691625600&amp;v=beta&amp;t=-DDsuhK3gmvq0rdwcxNGzemh5wca2iEhrZ5Qp_lMHbI"><figcaption>Figure: The Attention Mechanism illustrated - Figure 1</figcaption></figure><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQEZl-bJ4a6oAQ" src="https://media.licdn.com/dms/image/D5612AQEZl-bJ4a6oAQ/article-inline_image-shrink_400_744/0/1686325442542?e=1691625600&amp;v=beta&amp;t=Cj_ywxoLXzjLr7HVKfz397AxI-n0-_HLo8yUAyW0vLE"><figcaption>Figure: The Attention Mechanism illustrated - Figure 2</figcaption></figure><p>The Attention Scores which are formulated as a dot product of Q and K clearly illustrate how much each word is dependent on other words through the matrix shown (again below):</p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQEeU2LBJh6chA" src="https://media.licdn.com/dms/image/D5612AQEeU2LBJh6chA/article-inline_image-shrink_400_744/0/1686325560492?e=1691625600&amp;v=beta&amp;t=AH0R0Oje0NK7KZscujRg467HDguFiFpGY6jH5lPd4mA"><figcaption>Figure: The Attention Scores</figcaption></figure><p><br></p><p>Several such attention heads are used in the Transformer architecture which results in the concept of Multi Headed Attention.</p><p>&nbsp;</p><p>&nbsp;<strong>Multi-Headed Attention</strong></p><p>The operation of taking the positional encoding, passing it through a neural network unit for computation of query, key and value matrices respectively is called an Attention Head. </p><p>In<strong> </strong>Multi Headed Attention we split each of these vectors into 8 pieces. Each piece now being termed as an "Attention Head".</p><p>Thus, the Query, Key, Value vectors being learnt involved 8 pieces. Each piece being termed as Attention Head. Once the Query Key Value vectors were learnt for each head, the Similarity metric Q*K established the Attention matrix for EACH head.</p><p> </p><p><strong>Carrying out the process 8 times I. e. breaking down the Q K V into 8 heads resulted in much more contextually aware vectors.</strong></p><p> </p><p>And the parallel processing allowed out us to use GPUs for all the computational processing in the math going on!</p><p>&nbsp;</p><p><strong>Conclusions from the Attention Mechanism:</strong></p><p>Following may be concluded from the discussions above:</p><p>1.&nbsp;&nbsp;All the above operations encode the input to represent “attention” information.</p><p>2.&nbsp;&nbsp;&nbsp;For a language model, the attention weights help us understand what parts of text to focus on to predict the next word.</p><p>3.&nbsp;&nbsp;&nbsp;For a language translation task, it will help the decoder to focus on specific part of the text during decoding process.</p><p>4.&nbsp;&nbsp;&nbsp;The above steps eliminated the need for sequential processing and have captured the semantic meaning of sentence through the attention mechanism.&nbsp;</p><p><br></p><h3>8.3 Understanding of the overall working of the Transformer at a high level</h3><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQFKMtCG1w_HgQ" src="https://media.licdn.com/dms/image/D5612AQFKMtCG1w_HgQ/article-inline_image-shrink_1000_1488/0/1686325683774?e=1691625600&amp;v=beta&amp;t=MokEfMNiKRH-8F6Nf8l65PtOnopFYrzUeKfWl5YF9tk"><figcaption>Figure: The Transformer Architecture</figcaption></figure><p>On reading the paper: “Attention is All You Need”, it doesn’t give you the impression that it was written with the intention of being the foundation of large language models – GPT, BERT (as discussed below). The paper was written with the intention of accomplishing a specific task related to language translation – therefore even though language translation through deep learning is not a topic of this blog it might be worthwhile to discuss at a very high level. Let us assume we’re translating from English to French.</p><p>&nbsp;</p><p>The Transformer architecture consists of 2 parts: the Encoder and the Decoder. During training the Encoder will take the English words (word embeddings) and will generate word vectors simultaneously. These word vectors (as illustrated in the figure below) are contextually aware because of the Attention mechanism as discussed above in quite detail.</p><p><br></p><figure class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D5612AQFa5fAjbIaKhA" src="https://media.licdn.com/dms/image/D5612AQFa5fAjbIaKhA/article-inline_image-shrink_400_744/0/1686325747893?e=1691625600&amp;v=beta&amp;t=0NKddRTdA9bkU49YC7vx0AXYJ2jYR-0CH5W-BEXdCpw"><figcaption>Figure: Contextually aware word embeddings <br>from the Encoder because of the Attention mechanism</figcaption></figure><p>Next, to the Decoder – in the start – we pass the English (contextually aware) word vectors generated along with a start token signifying the start of the sentence and start generating the French words one after the other. Each time we want to determine the nth French word, we pass in all the English word vectors and the (n-1) French words generated up to that step.</p><p>To determine the model’s loss – we compare the predicted and the true class – the loss (cross entropy loss) is computed for every predicted word and added to get the total loss. The loss is then back propagated through the network to update the weights / parameters of the network. This is the Training a <strong><u>very high level</u></strong> that occurs in the Transformers. </p><p>What’s really important in the above architecture is that we have 2 components: &nbsp;an encoder and decoder that have a contextual understanding of language, if we stack the encoder we get “Bidirectional encoding of Transformer”, if we stack the decoder, we get the decoder we get “Generative Pre-trained Transformer”.</p><p>Following points may be noted:</p><p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>The Encoder only models</strong> are good for tasks that require understanding of input such as sentiment classification and named entity recognition (NER)</p><p>&nbsp;</p><p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Decoder only models</strong> are Good for generative tasks such as text generation – language models.</p><p>&nbsp;</p><p>&nbsp;</p><p>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Encoder-Decoder models</strong>: Good for generative tasks such as text summarization or translation (many-to-many)</p><p>&nbsp;</p><p>I will be ending this blog with this – the subsequent blogs will go into the detail of each unit of the transformer along with the code.</p></div>
</body>
</html>