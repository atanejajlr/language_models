<html>
<head>
  <title>Feature Engineering – Data Cleansing, Transformation and Selection - my notes</title>
  <style>
    body {
      margin: 0 auto;
      width: 744px;
      font-family: Source Serif Pro, serif;
      line-height: 32px;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.7);
      font-size: 21px;
    }
    h1, h2, h3 {
      font-family: Source Sans Pro, Helvetica, Arial, sans-serif;
    }
    h1 a, h1 a:visited {
      color: inherit;
      text-decoration: none;
    }
    h1 {
      line-height: 48px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 42px;
      margin: 32px 0 20px;
    }
    h2 {
      line-height: 32px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 26px;
      margin: 28px 0;
    }
    h3 {
      line-height: 28px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 21px;
      margin: 24px 0;
    }
    p {
      margin: 32px 0;
    }
    .created, .published {
      color: rgba(0, 0, 0, 0.55);
      font-size: 15px;
      line-height: 15px;
      margin: 20px 0;
    }
    .created + .published {
      margin-top: -12px;
    }
    blockquote {
      font-family: Georgia, Source Serif Pro, serif;
      font-style: italic;
      font-size: 24px;
      line-height: 36px;
      margin: 48px 120px;
      text-align: center;
    }
    a {
      word-wrap: break-word;
      outline: none;
      text-decoration: none;
      background-color: transparent;
      border: 0;
      color: #008CC9;
    }
    a:hover {
      text-decoration: underline;
    }
    a:visited {
      color: #8C68CB;
    }
    .center {
      text-align: center;
    }
    iframe {
      display: block;
      margin: 44px auto;
    }
    *:not(pre) + pre, pre:first-of-type {
      margin-top: 32px;
      padding-top: 32px;
    }
    pre:only-of-type {
      margin: 32px 0;
      padding: 32px;
    }
    pre {
      background: #F3F6F8;
      overflow-x: auto;
      display: block;
      font-size: 13px;
      font-family: monospace;
      line-height: 13px;
      padding: 0 32px 32px;
      white-space: pre;
    }
    a.embedded {
      background: #F3F6F8;
      display: block;
      padding: 32px;
      margin: 32px 0;
    }
    img {
      height: auto;
      max-width: 100%;
    }
    .slate-image-embed__resize-full-width img {
      width: 100%;
    }
    .series-logo {
      width: 48px;
      height: 48px;
      box-sizing: border-box;
      background-clip: content-box;
      border: 4px solid transparent;
      border-radius: 6px;
      object-fit: scale-down;
      float: left;
    }
    .series-title {
      font-size: 16px;
      font-weight: 600;
      vertical-align: top;
    }
    .series-description {
      color: rgba(0,0,0,.6);
      font-weight: 400;
      font-size: 14px;
      line-height: 20px;
    }
    div {
      margin: 32px 0;
    }
  </style>
</head>
<body>
    <img src="https://media.licdn.com/mediaD4E12AQEudFhrkMeWQA" alt="" title="" />
      <h1><a href="https://www.linkedin.com/pulse/feature-engineering-data-cleansing-transformation-selection-taneja">Feature Engineering – Data Cleansing, Transformation and Selection - my notes</a></h1>
    <p class="created">Created on 2018-06-16 17:15</p>
  <p class="published">Published on 2022-11-03 20:56</p>
  <div><h2>1.&nbsp;&nbsp;&nbsp;Data pre-processing:</h2><p>All machine learning models require data pre-processing to improve training. The way the data is represented can have a strong influence on how the machine learning model can learn from it. For example, models tend to converge more faster and reliably when numerical data is scaled appropriately. The techniques for selecting and transforming the data are key to the to increase the predictive quality of the models. </p><p>The art of feature engineering tries to improve the model’s ability to learn while reducing the compute resources if required. It does so by transforming and projecting (e. g. dimensionality reduction), eliminating (feature selection methods) or combining the features in the raw data to form a new version of the data set</p><p><strong>Important: Feature Engineering should be consistent in training and serving</strong></p><p>During training you have the entire data set available to you. So, one can use the global properties of individual features in the feature engineering transformation. </p><ul><li>For example, you can compute standard deviation of the features and use that to perform normalization. It should be underscored that when you serve the model you should do the same kind of feature engineering so that you give the model the same kind of data the model was trained on. So, if you have normalized the data and have used standard deviation, then, such global constants should be saved and also made use of during serving. Failing to do that is a very common source of problem in production systems and such errors can be difficult to debug. </li><li>Or, if you created a one hot vector for a categorical feature when you trained, you need also to create a one hot vector when you serve the model.</li></ul><p>This series/document will comprise of the following topics related to feature engineering:</p><ul><li>Section 2 will throw some light on the pre-processing operations that are used for feature engineering</li><li>Section 3 will be about Data cleansing and will talk about some of the statistical methods that may be used to detect outliers in the dataset.</li><li>Section 4 will point to my Git repository which has the Jupyter notebooks showing some data cleansing exercises using different approaches</li><li>Section 5 will talk about feature scaling and then section 6 will comprise notebook &nbsp;relating to Feature Scaling. </li></ul><p><br></p><h2>2.&nbsp;&nbsp;&nbsp;Pre-processing operations</h2><p>Let us talk about some of the pre-processing operations that are used for feature engineering</p><p><strong>&nbsp;</strong></p><ul><li><strong>Data cleansing: </strong>This involves eliminating or correcting erroneous data</li></ul><p><br></p><ul><li><strong>Feature tuning: </strong>It is often required to perform transformation on the data like scaling, normalizing the data since machine learning models and neural networks are sensitive to range of numerical features.</li></ul><p><br></p><ul><li><strong>Feature extraction: Dimensionality reduction vs feature selection methods: </strong>One shouldn't just throw everything at your machine learning model and rely on your training process to determine which features are actually useful. Thus, it is imperative to carry out feature selection and | or dimensionality reduction to reduce the number of features in a dataset. Whilst both ‘feature selection’ and ‘dimensionality reduction’ are used for reducing the number of features in a dataset, there is an important difference:</li></ul><p>◾Feature selection is simply selecting and excluding given features WITHOUT changing them</p><p>◾Whereas Dimensionally Reduction transforms the features into a lower dimension</p><p>&nbsp;Feature selection identifies the features that best represent the relationship amongst all in the feature space as well as the target that the model will try to predict. Feature selection methods remove the features that do not influence the outcome. This reduces the size of the feature space, hence reducing the resource requirements for processing the data and model complexity too. I have discussed about Feature Selection and Dimensionality reduction here: <a href="https://www.linkedin.com/pulse/feature-selection-dimensionality-reduction-ajay-taneja/" target="_blank">https://www.linkedin.com/pulse/feature-selection-dimensionality-reduction-ajay-taneja/</a></p><ul><li><strong>Bucketizing and Binning: </strong>Sometimes it may be useful to bucket different data ranges into a one hot encoding as shown below. For example, if you’re dealing with a houses data set built over years, one could bucket different years as shown below:</li></ul><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQFRa2U6DQnzpA" src="https://media.licdn.com/dms/image/D4E12AQFRa2U6DQnzpA/article-inline_image-shrink_400_744/0/1666592942789?e=1691625600&amp;v=beta&amp;t=a2aRchM6s8JvBzWFnG_VNqGbt9kRaZ86Wxr2hPL4Lo8"></div><h2>3.&nbsp;&nbsp;&nbsp;Data Cleansing</h2><p>As mentioned, data cleansing involves eliminating or correcting erroneous data. Outliers are generally defined as samples that are generally far away from the mainstream of the data. Outliers in the dataset may be caused by measurement or input error, data corruption, etc. Statistical methods may be used to detect outliers in the dataset. Some of these methods are discussed below. However, the point that should be highlighted is that any of the methods discussed should be used carefully. In the end, it comes down to your subject area knowledge and the investigation of the candidate outlier. It is always possible than an unusual value is part of the natural variation of the process rather than a problematic point.</p><p><br></p><h2>3.1 Percentile method:</h2><p>In the percentile method, you decide a specific threshold in percentile. For example, anything above 98% percentile and below 2% percentile may be considered as an outlier and then you go ahead trimming or capping these samples from the dataset. Percentile method is arbitrary, and you will have to determine the threshold manually based on domain knowledge. </p><p>The Jupyter notebook shown below has a dataset where data above 98th percentile and below 2nd percentile is is removed. The Airbnb dataset is from Kaggle</p><p><br></p><h2>3.2 Using Z-score to detect outliers</h2><p><br></p><p>Z-score quantifies the unusualness of an observation when your data follows a normal distribution. Z-scores are the number of standard deviations above and below the mean each value falls. A z-score of 2 indicates that an observation is 2 standard deviations above average whilst a Z-score of -2 indicates it is 2 standard deviations below the average.</p><p>Mathematically,</p><p>Z-score, is given by:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQG2f0BJ6TPBlQ" src="https://media.licdn.com/dms/image/D4E12AQG2f0BJ6TPBlQ/article-inline_image-shrink_400_744/0/1666593022857?e=1691625600&amp;v=beta&amp;t=RgadJOjElcX-ojB1uCELEGAuXm8ykg17qj6u7mG7mxY"></div><h3>Percentile vs Z score:</h3><p>It must be underscored that whilst the percentile uses the median as an average (50th percentile), Z-score uses the mean as an average. Thus, a Z-score of 0 represents a value equal to the mean. The farthest away a Z-score is from mean, the more unusual it is. </p><p><br></p><h2>3.3 Removal of outliers using the Interquartile Range (IQR)</h2><p>Unlike the more familiar, mean and standard deviation, the interquartile range and the median are robust measures. IF the dataset is normally distributed, you can use standard deviation to determine the percentage of observation that fall specific distances from the mean. However, that does not work for if the data is not normally distributes/skewed distribution and IQR is an excellent alternative. </p><p><br></p><p><strong>What is Interquartile Range?</strong></p><p>Interquartile Range (IQR) measures the spread of the middle half of the data. It is the range for the middle 50% of your sample. IQR is used to assess the variability of where most of the values lie. To find the outliers, a multiplier (normally, 1.5) is used to subtract from the 25th percentile – which gives a lower limit of Q1 – 1.5 IQR and to add to the 75th percentile (i.e., an upper limit of Q3 + 1.5 IQR) is used. Any samples beyond the lower and upper limit are classified as “outliers”.</p><p>The figure below illustrates the math better:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQFnqkjoVs19Yg" src="https://media.licdn.com/dms/image/D4E12AQFnqkjoVs19Yg/article-inline_image-shrink_400_744/0/1667421258381?e=1691625600&amp;v=beta&amp;t=PLi2VAbmXn_-SgSbER6fkN5-S0aWmfxa6LOt7MdeVe0"></div><p><br></p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQHWsULxSQbLOw" src="https://media.licdn.com/dms/image/D4E12AQHWsULxSQbLOw/article-inline_image-shrink_1000_1488/0/1667421338943?e=1691625600&amp;v=beta&amp;t=I2Tawd1IGjazWDCtbfkrZDajxWbFcSc6Fv634jN548E"></div><h2>4.&nbsp;&nbsp;&nbsp;Notebook examples of Data Cleansing</h2><p>The Jupyter notebooks in my Github link below illustrate the following:</p><ol><li>Detecting and eliminating outliers using percentile</li><li>Detecting and and eliminating outliers using Z-score</li><li>Detecting and eliminating outliers using&nbsp;IQR</li></ol><p>This is the Github link: <a href="https://github.com/atanejajlr/linkedin_feature_engineering" target="_blank">https://github.com/atanejajlr/linkedin_feature_engineering</a></p><p><br></p><h2>5.&nbsp;&nbsp;&nbsp;Feature Scaling</h2><p><br></p><h2>5.1&nbsp;&nbsp;&nbsp;Why Feature Scaling?</h2><p>Real world datasets often contain features that vary in their degree of magnitude and units. Therefore, in order that the machine learning model interprets all features in the same scale we have to perform “feature scaling”.</p><p>Feature scaling helps algorithms for minimization of cost function such as gradient descent converge faster as well as become mandatory in many cases as discussed in section. To understand feature scaling, let us examine the relationship between feature values and the parameters through an example.</p><p><br></p><p><strong>Importance of Feature Scaling:</strong></p><p>To understand the importance of feature scaling in the most intuitive sense, think about Principal Component Analysis (PCA)</p><p> PCA attempts to locate the principal components by choosing a "u" (the direction along which you project the data points) so that you get the maximum variance. You want the maximum variance because you want to retain the maximum information from your data set.</p><p> Suppose your data set comprises of 'height' and 'weight' feature, then, because of the inherent difference in scales in height and weight , PCA might determine the direction of maximal variance corresponding with the ‘weight’ axis - in case if no feature scaling is done - which is clearly incorrect because a variation of height of 1m is highly significant. Hence feature scaling becomes mandatory here.</p><p> As well as in algorithms like K Nearest Neighbours where you deal with Euclidian distances.</p><p><br></p><h2>5.2&nbsp;&nbsp;&nbsp;Understanding Feature Scaling through an example</h2><p><br></p><p>Let us consider the “Hello World” example of machine learning wherein you’re predicting the price of the house – and the associated features being:</p><ul><li>Size in square feet – feature x1</li><li>Number of bedrooms – feature x2</li></ul><p><br></p><p>Here the size in square feet may range from 300 – 2000 square feet and the number of bedrooms may range from 0 – 5. So, the feature x1 takes on relatively large range of values and the feature x2 takes relatively smaller range of values. </p><p>Let us say the model associated with the price prediction is given by the following equation and let us say we’re predicting the price for a 5-bedroom house of size 2000 square feet.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQES2KKU6HIFEQ" src="https://media.licdn.com/dms/image/D4E12AQES2KKU6HIFEQ/article-inline_image-shrink_400_744/0/1667421877684?e=1691625600&amp;v=beta&amp;t=pZSxLD9EPE_bqW4nPp5oVcjz6QeJzTRn4i4X3EoXDac"></div><p>One choice of the parameters of the model can be:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQFZHCywzrlUNA" src="https://media.licdn.com/dms/image/D4E12AQFZHCywzrlUNA/article-inline_image-shrink_400_744/0/1667421923786?e=1691625600&amp;v=beta&amp;t=955CSr8VF9FBEvhiCq_xlPXSX3vIRAu1EY_LnwtmRKs"></div><p>This will result in the price evaluation of:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEhB3lmXqTx3Q" src="https://media.licdn.com/dms/image/D4E12AQEhB3lmXqTx3Q/article-inline_image-shrink_400_744/0/1667421971619?e=1691625600&amp;v=beta&amp;t=kbczX64irljatoboD3Y43LZ1qPjfvao14-JtbeZ60sI"></div><p><br></p><p>Let’s say that a price of 500K is approximately the right price, thus, the model has evaluated the parameters correctly.</p><p>Here, it may be noticed that when the feature value is relatively large (x1 -&gt; 2000 square feet), the corresponding parameter value is small (w1 being 0.1) and when the feature value is relatively small (x2 being 5 bedrooms), the corresponding parameter value is relatively large (w2 being 50). </p><p>Let us examine the above visually. Let us get a scatter plot of the features: the size in square feet is on the horizontal axis vs number of bedrooms is on the vertical axis&nbsp;-for some of the training examples as shown below:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQGuv3mz2xugWw" src="https://media.licdn.com/dms/image/D4E12AQGuv3mz2xugWw/article-inline_image-shrink_1000_1488/0/1667422070932?e=1691625600&amp;v=beta&amp;t=tAbx-mLNmIPHdQ9p-CO0u3aNnVIj3VB7Y-OCzsccFaM"></div><p>Now, let us see how the cost function might look in the contour plot. It may be recalled that by definition of a “contour” – all points on a particular contour denote same value of cost function.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQFu5qdMLR6xeA" src="https://media.licdn.com/dms/image/D4E12AQFu5qdMLR6xeA/article-inline_image-shrink_1000_1488/0/1667422118861?e=1691625600&amp;v=beta&amp;t=U8wvgRE0BD5MVqHTcNFaQ5mjlM-hjSQE7y45wnUTHlk"></div><p>As it may be noticed from the figure above, the contours form ellipses which are shorter along one side (side corresponding to w1 and longer along the other – the axis corresponding to w2. </p><p>In such a case the minimization algorithm such as the gradient descent might take a very long time to converge as it might bounce back and forth before it can find the global minima as emulated in the figure below:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEoksuFwAoKww" src="https://media.licdn.com/dms/image/D4E12AQEoksuFwAoKww/article-inline_image-shrink_1000_1488/0/1667422236487?e=1691625600&amp;v=beta&amp;t=02LLA0U7io_sJDkUy9FlUXWlJweoMwN9WkzwtKSZVG4"></div><p><strong>How do we solve the above problem?</strong></p><p>In such a case, it might be useful to scale the features i.e., x1 the sq feet and x2 the number of bedrooms so that the scaled/transformed features lie between 0 and 1. And after the transformation, the scatter plot looks as shown in the figure below:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQHZ7xZikY1UPQ" src="https://media.licdn.com/dms/image/D4E12AQHZ7xZikY1UPQ/article-inline_image-shrink_1000_1488/0/1667422322089?e=1691625600&amp;v=beta&amp;t=igMDMz3Bnh_ai41OnF4vJl9GXfSP5ILZoyAxfMpv3FQ"></div><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQFL0x2b0v6hXQ" src="https://media.licdn.com/dms/image/D4E12AQFL0x2b0v6hXQ/article-inline_image-shrink_1000_1488/0/1667422364998?e=1691625600&amp;v=beta&amp;t=qTmeTg7lWP3wMwIRqbEPG5mhfj8Vo-MKSmnSW2eQ3Lk"></div><p>As it may be noticed, the scaled plot is different from the unscaled/un-transformed plot. This is because the scaled features x1 and x2 now take on compatible range of values to each other and now if you run the minimization algorithm like gradient descent on the scaled features the contour plots of the cost function look like below:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEkSvG0WnYVcw" src="https://media.licdn.com/dms/image/D4E12AQEkSvG0WnYVcw/article-inline_image-shrink_1000_1488/0/1667422404824?e=1691625600&amp;v=beta&amp;t=CW6yRnoNTRf15QW8B2Po7-SA64bNxoFfgBHOPF0S5k0"></div><p>As it may be noticed, the contour plots are no longer tall and skinny, and the gradient descent will find a direct path to the global minimum as shown in the figure below.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEs1xdyAe4VIg" src="https://media.licdn.com/dms/image/D4E12AQEs1xdyAe4VIg/article-inline_image-shrink_1000_1488/0/1667422444579?e=1691625600&amp;v=beta&amp;t=geZRvuOVHP8mbABn_DQD2zsy7ote2IYs7-K65no1QyU"></div><p>Thus, to conclude, it can be stated: if you have different features that take on different range of values it can cause algorithm like gradient descent to converge slowly but rescaling the features so that they comparable values may speed up the minimization algorithm significantly.</p><p><br></p><h2>5.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Possible ways to scale features</h2><p><br></p><p>Let us now see the possible ways to scale the features, these include:</p><p><br></p><ul><li>Divide by maximum: Here we take each feature and divide each sample of the feature by the maximum value so that every value will lie between 0 and 1 (&nbsp;0 &lt;=x1 &lt;=1)</li></ul><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEAHTMMwfTeyA" src="https://media.licdn.com/dms/image/D4E12AQEAHTMMwfTeyA/article-inline_image-shrink_1000_1488/0/1667422563406?e=1691625600&amp;v=beta&amp;t=S4S1LGs87Rx5IqRQMX_mHBooJYOuqVv84xH6zyVFH24"></div><p>Thus, considering the same example hosing price data set,</p><p>Originally,</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQHYtiSBzClxKw" src="https://media.licdn.com/dms/image/D4E12AQHYtiSBzClxKw/article-inline_image-shrink_400_744/0/1667422772073?e=1691625600&amp;v=beta&amp;t=5Evb5Z-hBveGPfpg3KPXJEKag8G9Stuj8jGUHcWWrU0"></div><p><br></p><p>Scaling by divide by maximum:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQE7pmVqQmZG1w" src="https://media.licdn.com/dms/image/D4E12AQE7pmVqQmZG1w/article-inline_image-shrink_400_744/0/1667422822913?e=1691625600&amp;v=beta&amp;t=TZ19KbD1Ar0gw-pihY1LBIwdmnHeVSejekil-Lql508"></div><p>Thus,</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQF6CxNA7tsddA" src="https://media.licdn.com/dms/image/D4E12AQF6CxNA7tsddA/article-inline_image-shrink_400_744/0/1667422863085?e=1691625600&amp;v=beta&amp;t=dtaptckh_eRQ4YqBFJbGkILVK4r1qCDDNqIhj3rR_tI"></div><ul><li>Mean normalization: In Mean normalization, one starts with the original features and re-scales them so that they are centred around 0. Normally, the features will lie between -1 and +1. The re-scaled features based on mean normalization will be:</li></ul><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQH4v6vBKa89oA" src="https://media.licdn.com/dms/image/D4E12AQH4v6vBKa89oA/article-inline_image-shrink_400_744/0/1667422910557?e=1691625600&amp;v=beta&amp;t=-pr0n9jF4ihQwKJfCpmDWFLAvu8q22LYwATezgZqAgg"></div><p><br></p><p>That is: for feature x1 we calculate the mean of x1 for all the training examples and then take the corresponding maximum and minimum value of the feature x1 of all the training examples.</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQHYUflpY0uFNQ" src="https://media.licdn.com/dms/image/D4E12AQHYUflpY0uFNQ/article-inline_image-shrink_1000_1488/0/1667422949620?e=1691625600&amp;v=beta&amp;t=sKcuyKPcWm9HOKMSxHosXGyFwLHL3YVnxiJV-sw78f8"></div><ul><li>Z- score normalization: Another common feature scaling method is the Z-score normalization. To carry out the Z score normalization we have to calculate the standard deviation of each feature. Z-score normalization for feature x1 is given by:</li></ul><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQG5EC_366xuFg" src="https://media.licdn.com/dms/image/D4E12AQG5EC_366xuFg/article-inline_image-shrink_400_744/0/1667423117783?e=1691625600&amp;v=beta&amp;t=5TLSGvt577GOUySjhc3dh_E4fUq0dwyyPKQaYqV-VqQ"></div><p>where,</p><p>µ1 is the mean of all the training examples corresponding to feature x1 and &nbsp;is the standard deviation</p><p><br></p><h2>5.4&nbsp;&nbsp;&nbsp;&nbsp;Scikit-Learn libraries for feature scaling</h2><p>There are 3 different types of scalars in the Scikit-learn library for feature scaling. These include:</p><ul><li>Min-Max Scalar</li><li>Standard Scalar</li><li>Robust Scalar</li></ul><p><strong>Min-Max Scalar:</strong></p><p>Using the Min-Max scalar, all the features will be transformed into the range: [0, 1] i.e., the minimum and maximum value of the feature will be between 0 and 1. The scaled value of a sample is given by:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQEWSibYejvHNA" src="https://media.licdn.com/dms/image/D4E12AQEWSibYejvHNA/article-inline_image-shrink_400_744/0/1667423330968?e=1691625600&amp;v=beta&amp;t=zstyUg0CA4pJeSlp-BpOF92EoACgGWlp-o4qaIU8TdY"></div><p><br></p><p><strong>Standard Scalar:</strong></p><p>Standard Scalar standardizes the features by removing the mean and scaling it to unit variance. The standard score of a sample is calculated as:</p><div class="slate-resizable-image-embed slate-image-embed__resize-full-width"><img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4E12AQGuHguXKUlxFA" src="https://media.licdn.com/dms/image/D4E12AQGuHguXKUlxFA/article-inline_image-shrink_400_744/0/1667423371669?e=1691625600&amp;v=beta&amp;t=tUIgiwHlM70RxIQq__pYBjzi3y2Sb9qB4NgL99sJDc0"></div><p><br></p><p><br></p><p>Where, µ and σ are the mean and the standard deviation respectively</p><p>The mean and the standard deviation are stored to be used later during model serving. Standard scalar is often used in many machine learning algorithms. However, the algorithm may not work well if the individual feature is not more or less standard normal distributed. </p><p><br></p><p><strong>Robust Scalar:</strong></p><p>This scalar removes the median and scales the data according to the quantile range – the Interquartile Range (IQR) which lies between the first and the third quantile.</p><p>It must be underscored that standardization of the dataset is often carried out – i.e., using the standard scalar as described above, However, outliers can influence the mean/variance in a negative way and in such circumstances, the median and the interquartile range will give better results</p><p><br></p><p><strong>Which is the preferred Scalar? Min-Max scalar | Standard Scalar | Robust Scalar?</strong></p><p>Min-Max Scalar will transform each value in the column in proportion within the range [0,1]. </p><p>Standard Scalar will transform each value in the column in the range about the mean and the standard deviation. The method is used when the distribution is Gaussian </p><p>If there are outliers in the dataset Robust Scalar is the preferred option. Alternative to that, if one has dealt with the outliers in an exploratory Data Analysis Standard Scalar or Min Max scalar may be resorted to depending on whether the data is normally distributed or not. </p><p><br></p><h2>6.&nbsp;&nbsp;Notebook illustrations of feature scaling</h2><p>The Jupyter notebook in the Github link mentioned below shows some example illustrations of featue ecaling using scikit-learn libraries:</p><p>This is the Github link: <a href="https://github.com/atanejajlr/linkedin_feature_engineering" target="_blank">https://github.com/atanejajlr/linkedin_feature_engineering</a></p><p><br></p><h2>7.&nbsp;&nbsp;Feature Selection Methods: Introduction</h2><p>Having spoke about: Data Cleansing, various statistical techniques for data cleansing followed by feature scaling and the importance of feature scaling in algorithms like Principal Component Analysis, K-Nearest Neighbours as well as during the minimization of cost function and some of my notebooks demonstrating these techniques for data cleansing and feature scaling, it is time to discuss some of the feature selection methods. </p><p>In this article:<a href="https://www.linkedin.com/pulse/feature-selection-dimensionality-reduction-ajay-taneja/" target="_blank">https://www.linkedin.com/pulse/feature-selection-dimensionality-reduction-ajay-taneja/</a>&nbsp;, I have discussed in sufficient detail about the feature selection methods – hence this post will focus on pointing out some highlights and notebooks demonstrating the application of these methods. </p><p><br></p><h2>8.&nbsp;&nbsp;Highlights of the feature selection methods</h2><p><br></p><p>Feature selection methods may be classified into supervised and unsupervised methods. Whereas, supervised methods consider the correlation between the features and the target variable, the unsupervised methods do not consider the correlation between features and the target variable. </p><p>The methods that fall under supervised feature selection include: </p><ul><li>Filter methods</li><li>Wrapper methods and</li><li>Embedded methods</li></ul><p><strong>Filter methods:</strong></p><p>In <strong>Filter methods</strong>, we start with all the features and select the best subset that we are going to give to the machine learning model. In these methods, we get a correlation matrix that tells us how the features are corelated with one another and the target variable. Some of the correlations commonly used are Pearson’s correlation, Kendall Tau Rank correlation and Spearman corelation. </p><p><strong>Wrapper methods:</strong></p><p>Popular methods for feature selection include Forward elimination, Backward elimination and Recursive feature elimination</p><p><strong>&nbsp;Forward selection</strong> is a greedy method wherein we select one feature at a time, pass it to the machine learning model and evaluate the importance. We repeat the process increasing the features in every iteration until no improvement is seen. At this point, we generate a best subset of all the features. </p><p><strong>Backward selection</strong> is just the reverse of forward selection. In backward selection, we start with “all of the features” and evaluate the model performance by removing one feature at a time. </p><p><strong>Recursive feature elimination:</strong> In Recursive feature elimination, we use a model to evaluate feature importance. Random Forest Classifier is one of the model types wherein we can evaluate the feature importance.&nbsp;Firstly, we select the desired number of features and fit the model. The model ranks the features by importance and then we discard the least important features. We repeat until the desired number of features remain. Recursive Feature Selection often turns out to be best performing amongst all.</p><h2>9.&nbsp;&nbsp;Notebook illustrations of feature selection methods</h2><p>The Jupyter notebook in the Github link mentioned below shows some example illustrations of various feature selection techniques</p><p>This notebook runs through the different techniques in performing feature selection from a dataset and then compares the evaluation metrics using the subset of features on a model taking the baseline model with all features.</p><p>This is the Github link: <a href="https://github.com/atanejajlr/linkedin_feature_engineering" target="_blank">https://github.com/atanejajlr/linkedin_feature_engineering</a></p><p><br></p><h2>8.&nbsp;&nbsp;&nbsp;References</h2><p><br></p><p><strong>Boxplots:</strong></p><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://towardsdatascience.com/creating-boxplots-with-the-seaborn-python-library-f0c20f09bd57" target="_blank">https://towardsdatascience.com/creating-boxplots-with-the-seaborn-python-library-f0c20f09bd57</a></p><p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://datavizpyr.com/boxplots-with-points-using-seaborn-in-python/" target="_blank">https://datavizpyr.com/boxplots-with-points-using-seaborn-in-python/</a></p><p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.statology.org/box-plot-skewness/#:~:text=We%20can%20determine%20whether%20or,or%20%E2%80%9Cpositively%E2%80%9D%20skewed" target="_blank">https://www.statology.org/box-plot-skewness/#:~:text=We%20can%20determine%20whether%20or,or%20%E2%80%9Cpositively%E2%80%9D%20skewed</a>).</p><p><strong>You-Tube</strong></p><ol><li>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.youtube.com/watch?v=A3gClkblXK8&amp;list=PLeo1K3hjS3ut5olrDIeVXk9N3Q7mKhDxO&amp;index=5" target="_blank">https://www.youtube.com/watch?v=A3gClkblXK8&amp;list=PLeo1K3hjS3ut5olrDIeVXk9N3Q7mKhDxO&amp;index=5</a></li><li><a href="https://www.youtube.com/watch?v=A3gClkblXK8&amp;list=PLeo1K3hjS3ut5olrDIeVXk9N3Q7mKhDxO&amp;index=5" target="_blank">https://www.youtube.com/watch?v=A3gClkblXK8&amp;list=PLeo1K3hjS3ut5olrDIeVXk9N3Q7mKhDxO&amp;index=5</a></li></ol><p>AND</p><ol><li>Several web sources</li></ol><p><br></p></div>
</body>
</html>